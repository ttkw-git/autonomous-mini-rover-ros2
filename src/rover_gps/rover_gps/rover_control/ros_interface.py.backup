#!/usr/bin/env python3
"""
ROS2 interface for rover control
Handles ROS2 publishers, subscribers, Ackermann constraints, and LiDAR safety
"""

import time
import threading
from rclpy.node import Node
from geometry_msgs.msg import Twist
from sensor_msgs.msg import NavSatFix, Imu

from ackermann_handler import AckermannMovementHandler
from lidar_safety_monitor import LidarSafetyMonitor


class RoverROSInterface(Node):
    """ROS2 interface node for rover control with Ackermann constraints and LiDAR safety"""
    
    def __init__(self, enable_lidar_safety=True):
        super().__init__('rover_gui_interface')
        
        # Ackermann handler (always enabled)
        self.ackermann = AckermannMovementHandler()
        
        # LiDAR safety monitor
        self.enable_lidar_safety = enable_lidar_safety
        if enable_lidar_safety:
            self.lidar_safety = LidarSafetyMonitor(safety_distance=0.5, warning_distance=1.0)
            self.get_logger().info('LiDAR safety monitoring ENABLED')
        else:
            self.lidar_safety = None
            self.get_logger().info('LiDAR safety monitoring DISABLED')
        
        # GPS data storage
        self.latest_gps_lat = 0.0
        self.latest_gps_lon = 0.0
        self.latest_gps_status = -1
        self.gps_data_available = False
        self._gps_lock = threading.Lock()
        
        # Publishers
        self.cmd_vel_pub = self.create_publisher(Twist, '/controller/cmd_vel', 10)
        self.get_logger().info('Created cmd_vel publisher on: /controller/cmd_vel')
        
        # GPS Subscribers - try multiple topics
        self.gps_topics_to_try = ['/fix', '/gps/fix', '/nmea_fix', '/gps_fix']
        self.gps_sub = None
        self.current_gps_topic = None
        self.setup_gps_subscription()
        
        # Safety timer
        self.last_command_time = time.time()
        self.safety_timer = self.create_timer(0.5, self.safety_check)
        
        # Mode
        self.manual_mode = True
        
        self.get_logger().info('Rover ROS Interface initialized with Ackermann constraints')
    
    def setup_gps_subscription(self):
        """Try to find and subscribe to available GPS topic"""
        try:
            topic_list = self.get_topic_names_and_types()
            available_topics = [topic_name for topic_name, _ in topic_list]
            
            self.get_logger().info(f'Searching for GPS topics in {len(available_topics)} topics')
            
            for topic in self.gps_topics_to_try:
                if topic in available_topics:
                    try:
                        self.gps_sub = self.create_subscription(
                            NavSatFix, topic, self.gps_callback, 10)
                        self.current_gps_topic = topic
                        self.get_logger().info(f'Subscribed to GPS topic: {topic}')
                        return
                    except Exception as e:
                        self.get_logger().warn(f'Failed to subscribe to {topic}: {e}')
            
            # No GPS topic found - using Direct GPS instead
            self.get_logger().info('No ROS GPS topic found. Using Direct GPS handler.')
            
        except Exception as e:
            self.get_logger().error(f'GPS setup error: {e}')
    
    def gps_callback(self, msg):
        """GPS callback with thread-safe data storage"""
        try:
            with self._gps_lock:
                if abs(msg.latitude) > 90 or abs(msg.longitude) > 180:
                    return
                
                self.latest_gps_lat = msg.latitude
                self.latest_gps_lon = msg.longitude
                self.latest_gps_status = msg.status.status
                self.gps_data_available = True
                
        except Exception as e:
            self.get_logger().error(f'GPS callback error: {e}')
    
    def get_gps_data(self):
        """Thread-safe GPS data retrieval"""
        with self._gps_lock:
            return {
                'lat': self.latest_gps_lat,
                'lon': self.latest_gps_lon,
                'status': self.latest_gps_status,
                'available': self.gps_data_available,
                'topic': self.current_gps_topic
            }
    
    def send_cmd_vel(self, linear, angular):
        """Send velocity command with Ackermann constraints"""
        try:
            # Apply Ackermann constraints
            linear, angular = self.ackermann.calculate_safe_command(linear, angular, debug=False)
            
            msg = Twist()
            msg.linear.x = float(linear)
            msg.angular.z = float(angular)
            self.cmd_vel_pub.publish(msg)
            self.last_command_time = time.time()
            
        except Exception as e:
            self.get_logger().error(f'Command send error: {e}')
    
    def safety_check(self):
        """Safety check - stop if no commands received"""
        try:
            if self.manual_mode:
                if time.time() - self.last_command_time > 2.0:
                    stop_msg = Twist()
                    self.cmd_vel_pub.publish(stop_msg)
        except Exception as e:
            self.get_logger().error(f'Safety check error: {e}')
    
    def call_emergency_stop(self):
        """Call emergency stop"""
        try:
            stop_msg = Twist()
            self.cmd_vel_pub.publish(stop_msg)
            self.get_logger().warn('Emergency stop command sent')
        except Exception as e:
            self.get_logger().error(f'Emergency stop error: {e}')
